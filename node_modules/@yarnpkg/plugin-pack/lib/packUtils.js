"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.genPackList = exports.genPackageManifest = exports.genPackStream = exports.prepareForPack = exports.hasPackScripts = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const micromatch_1 = tslib_1.__importDefault(require("micromatch"));
const tar_stream_1 = tslib_1.__importDefault(require("tar-stream"));
const zlib_1 = require("zlib");
const NEVER_IGNORE = [
    `/package.json`,
    `/readme`,
    `/readme.*`,
    `/license`,
    `/license.*`,
    `/licence`,
    `/licence.*`,
    `/changelog`,
    `/changelog.*`,
];
const ALWAYS_IGNORE = [
    `/package.tgz`,
    `.github`,
    `.git`,
    `.hg`,
    `node_modules`,
    `.npmignore`,
    `.gitignore`,
    `.#*`,
    `.DS_Store`,
];
async function hasPackScripts(workspace) {
    if (core_1.scriptUtils.hasWorkspaceScript(workspace, `prepack`))
        return true;
    if (core_1.scriptUtils.hasWorkspaceScript(workspace, `postpack`))
        return true;
    return false;
}
exports.hasPackScripts = hasPackScripts;
async function prepareForPack(workspace, { report }, cb) {
    await core_1.scriptUtils.maybeExecuteWorkspaceLifecycleScript(workspace, `prepack`, { report });
    try {
        await cb();
    }
    finally {
        await core_1.scriptUtils.maybeExecuteWorkspaceLifecycleScript(workspace, `postpack`, { report });
    }
}
exports.prepareForPack = prepareForPack;
async function genPackStream(workspace, files) {
    var _a, _b;
    if (typeof files === `undefined`)
        files = await genPackList(workspace);
    const executableFiles = new Set();
    for (const value of (_b = (_a = workspace.manifest.publishConfig) === null || _a === void 0 ? void 0 : _a.executableFiles) !== null && _b !== void 0 ? _b : new Set())
        executableFiles.add(fslib_1.ppath.normalize(value));
    for (const value of workspace.manifest.bin.values())
        executableFiles.add(fslib_1.ppath.normalize(value));
    const pack = tar_stream_1.default.pack();
    process.nextTick(async () => {
        for (const fileRequest of files) {
            const file = fslib_1.ppath.normalize(fileRequest);
            const source = fslib_1.ppath.resolve(workspace.cwd, file);
            const dest = fslib_1.ppath.join(`package`, file);
            const stat = await fslib_1.xfs.lstatPromise(source);
            const opts = { name: dest, mtime: new Date(315532800000) };
            const mode = executableFiles.has(file)
                ? 0o755
                : 0o644;
            let resolveFn;
            let rejectFn;
            const awaitTarget = new Promise((resolve, reject) => {
                resolveFn = resolve;
                rejectFn = reject;
            });
            const cb = (error) => {
                if (error) {
                    rejectFn(error);
                }
                else {
                    resolveFn();
                }
            };
            if (stat.isFile()) {
                let content;
                // The root package.json supports replacement fields in publishConfig
                if (file === `package.json`)
                    content = Buffer.from(JSON.stringify(await genPackageManifest(workspace), null, 2));
                else
                    content = await fslib_1.xfs.readFilePromise(source);
                pack.entry({ ...opts, mode, type: `file` }, content, cb);
            }
            else if (stat.isSymbolicLink()) {
                pack.entry({ ...opts, mode, type: `symlink`, linkname: await fslib_1.xfs.readlinkPromise(source) }, cb);
            }
            else {
                cb(new Error(`Unsupported file type ${stat.mode} for ${fslib_1.npath.fromPortablePath(file)}`));
            }
            await awaitTarget;
        }
        pack.finalize();
    });
    const tgz = zlib_1.createGzip();
    pack.pipe(tgz);
    return tgz;
}
exports.genPackStream = genPackStream;
async function genPackageManifest(workspace) {
    const data = JSON.parse(JSON.stringify(workspace.manifest.raw));
    await workspace.project.configuration.triggerHook((hooks) => hooks.beforeWorkspacePacking, workspace, data);
    return data;
}
exports.genPackageManifest = genPackageManifest;
async function genPackList(workspace) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const project = workspace.project;
    const configuration = project.configuration;
    const globalList = {
        accept: [],
        reject: [],
    };
    for (const pattern of ALWAYS_IGNORE)
        globalList.reject.push(pattern);
    for (const pattern of NEVER_IGNORE)
        globalList.accept.push(pattern);
    globalList.reject.push(configuration.get(`rcFilename`));
    const maybeRejectPath = (path) => {
        if (path === null || !path.startsWith(`${workspace.cwd}/`))
            return;
        const workspaceRelativePath = fslib_1.ppath.relative(workspace.cwd, path);
        const workspaceAbsolutePath = fslib_1.ppath.resolve(fslib_1.PortablePath.root, workspaceRelativePath);
        globalList.reject.push(workspaceAbsolutePath);
    };
    maybeRejectPath(fslib_1.ppath.resolve(project.cwd, configuration.get(`lockfileFilename`)));
    maybeRejectPath(configuration.get(`bstatePath`));
    maybeRejectPath(configuration.get(`cacheFolder`));
    maybeRejectPath(configuration.get(`globalFolder`));
    maybeRejectPath(configuration.get(`installStatePath`));
    maybeRejectPath(configuration.get(`virtualFolder`));
    maybeRejectPath(configuration.get(`yarnPath`));
    await configuration.triggerHook((hooks) => {
        return hooks.populateYarnPaths;
    }, project, (path) => {
        maybeRejectPath(path);
    });
    // All child workspaces are ignored
    for (const otherWorkspace of project.workspaces) {
        const rel = fslib_1.ppath.relative(workspace.cwd, otherWorkspace.cwd);
        if (rel !== `` && !rel.match(/^(\.\.)?\//)) {
            globalList.reject.push(`/${rel}`);
        }
    }
    const ignoreList = {
        accept: [],
        reject: [],
    };
    const main = (_b = (_a = workspace.manifest.publishConfig) === null || _a === void 0 ? void 0 : _a.main) !== null && _b !== void 0 ? _b : workspace.manifest.main;
    const module = (_d = (_c = workspace.manifest.publishConfig) === null || _c === void 0 ? void 0 : _c.module) !== null && _d !== void 0 ? _d : workspace.manifest.module;
    const browser = (_f = (_e = workspace.manifest.publishConfig) === null || _e === void 0 ? void 0 : _e.browser) !== null && _f !== void 0 ? _f : workspace.manifest.browser;
    const bins = (_h = (_g = workspace.manifest.publishConfig) === null || _g === void 0 ? void 0 : _g.bin) !== null && _h !== void 0 ? _h : workspace.manifest.bin;
    if (main != null)
        ignoreList.accept.push(fslib_1.ppath.resolve(fslib_1.PortablePath.root, main));
    if (module != null)
        ignoreList.accept.push(fslib_1.ppath.resolve(fslib_1.PortablePath.root, module));
    if (typeof browser === `string`)
        ignoreList.accept.push(fslib_1.ppath.resolve(fslib_1.PortablePath.root, browser));
    for (const path of bins.values())
        ignoreList.accept.push(fslib_1.ppath.resolve(fslib_1.PortablePath.root, path));
    if (browser instanceof Map) {
        for (const [original, replacement] of browser.entries()) {
            ignoreList.accept.push(fslib_1.ppath.resolve(fslib_1.PortablePath.root, original));
            if (typeof replacement === `string`) {
                ignoreList.accept.push(fslib_1.ppath.resolve(fslib_1.PortablePath.root, replacement));
            }
        }
    }
    const hasExplicitFileList = workspace.manifest.files !== null;
    if (hasExplicitFileList) {
        ignoreList.reject.push(`/*`);
        for (const pattern of workspace.manifest.files) {
            addIgnorePattern(ignoreList.accept, pattern, { cwd: fslib_1.PortablePath.root });
        }
    }
    return await walk(workspace.cwd, {
        hasExplicitFileList,
        globalList,
        ignoreList,
    });
}
exports.genPackList = genPackList;
async function walk(initialCwd, { hasExplicitFileList, globalList, ignoreList }) {
    const list = [];
    const cwdFs = new fslib_1.JailFS(initialCwd);
    const cwdList = [[fslib_1.PortablePath.root, [ignoreList]]];
    while (cwdList.length > 0) {
        const [cwd, ignoreLists] = cwdList.pop();
        const stat = await cwdFs.lstatPromise(cwd);
        if (isIgnored(cwd, { globalList, ignoreLists: stat.isDirectory() ? null : ignoreLists }))
            continue;
        if (stat.isDirectory()) {
            const entries = await cwdFs.readdirPromise(cwd);
            let hasGitIgnore = false;
            let hasNpmIgnore = false;
            if (!hasExplicitFileList || cwd !== fslib_1.PortablePath.root) {
                for (const entry of entries) {
                    hasGitIgnore = hasGitIgnore || entry === `.gitignore`;
                    hasNpmIgnore = hasNpmIgnore || entry === `.npmignore`;
                }
            }
            const localIgnoreList = hasNpmIgnore
                ? await loadIgnoreList(cwdFs, cwd, `.npmignore`)
                : hasGitIgnore
                    ? await loadIgnoreList(cwdFs, cwd, `.gitignore`)
                    : null;
            let nextIgnoreLists = localIgnoreList !== null
                ? [localIgnoreList].concat(ignoreLists)
                : ignoreLists;
            if (isIgnored(cwd, { globalList, ignoreLists }))
                nextIgnoreLists = [...ignoreLists, { accept: [], reject: [`**/*`] }];
            for (const entry of entries) {
                cwdList.push([fslib_1.ppath.resolve(cwd, entry), nextIgnoreLists]);
            }
        }
        else if (stat.isFile() || stat.isSymbolicLink()) {
            list.push(fslib_1.ppath.relative(fslib_1.PortablePath.root, cwd));
        }
    }
    return list.sort();
}
async function loadIgnoreList(fs, cwd, filename) {
    const ignoreList = {
        accept: [],
        reject: [],
    };
    const data = await fs.readFilePromise(fslib_1.ppath.join(cwd, filename), `utf8`);
    for (const pattern of data.split(/\n/g))
        addIgnorePattern(ignoreList.reject, pattern, { cwd });
    return ignoreList;
}
function normalizePattern(pattern, { cwd }) {
    const negated = pattern[0] === `!`;
    if (negated)
        pattern = pattern.slice(1);
    if (pattern.match(/\.{0,1}\//))
        pattern = fslib_1.ppath.resolve(cwd, pattern);
    if (negated)
        pattern = `!${pattern}`;
    return pattern;
}
function addIgnorePattern(target, pattern, { cwd }) {
    const trimed = pattern.trim();
    if (trimed === `` || trimed[0] === `#`)
        return;
    target.push(normalizePattern(trimed, { cwd }));
}
function isIgnored(cwd, { globalList, ignoreLists }) {
    if (isMatch(cwd, globalList.accept))
        return false;
    if (isMatch(cwd, globalList.reject))
        return true;
    if (ignoreLists !== null) {
        for (const ignoreList of ignoreLists) {
            if (isMatch(cwd, ignoreList.accept))
                return false;
            if (isMatch(cwd, ignoreList.reject)) {
                return true;
            }
        }
    }
    return false;
}
function isMatch(path, patterns) {
    let inclusives = patterns;
    const exclusives = [];
    for (let t = 0; t < patterns.length; ++t) {
        if (patterns[t][0] !== `!`) {
            if (inclusives !== patterns) {
                inclusives.push(patterns[t]);
            }
        }
        else {
            if (inclusives === patterns)
                inclusives = patterns.slice(0, t);
            exclusives.push(patterns[t].slice(1));
        }
    }
    if (isMatchBasename(path, exclusives))
        return false;
    if (isMatchBasename(path, inclusives))
        return true;
    return false;
}
function isMatchBasename(path, patterns) {
    let paths = patterns;
    const basenames = [];
    for (let t = 0; t < patterns.length; ++t) {
        if (patterns[t].includes(`/`)) {
            if (paths !== patterns) {
                paths.push(patterns[t]);
            }
        }
        else {
            if (paths === patterns)
                paths = patterns.slice(0, t);
            basenames.push(patterns[t]);
        }
    }
    if (micromatch_1.default.isMatch(path, paths, { dot: true, nocase: true }))
        return true;
    if (micromatch_1.default.isMatch(path, basenames, { dot: true, basename: true, nocase: true }))
        return true;
    return false;
}
