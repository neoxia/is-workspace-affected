"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const core_3 = require("@yarnpkg/core");
const clipanion_1 = require("clipanion");
const enquirer_1 = require("enquirer");
const micromatch_1 = tslib_1.__importDefault(require("micromatch"));
const suggestUtils = tslib_1.__importStar(require("../suggestUtils"));
// eslint-disable-next-line arca/no-default-export
class UpCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.patterns = [];
        this.interactive = null;
        this.exact = false;
        this.tilde = false;
        this.caret = false;
    }
    async execute() {
        var _a;
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_2.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        const interactive = (_a = this.interactive) !== null && _a !== void 0 ? _a : configuration.get(`preferInteractive`);
        const modifier = suggestUtils.getModifier(this, project);
        const strategies = interactive ? [
            suggestUtils.Strategy.KEEP,
            suggestUtils.Strategy.REUSE,
            suggestUtils.Strategy.PROJECT,
            suggestUtils.Strategy.LATEST,
        ] : [
            suggestUtils.Strategy.PROJECT,
            suggestUtils.Strategy.LATEST,
        ];
        const allSuggestionsPromises = [];
        const unreferencedPatterns = [];
        for (const pattern of this.patterns) {
            let isReferenced = false;
            // The range has to be static
            const pseudoDescriptor = core_3.structUtils.parseDescriptor(pattern);
            for (const workspace of project.workspaces) {
                for (const target of [suggestUtils.Target.REGULAR, suggestUtils.Target.DEVELOPMENT]) {
                    const descriptors = workspace.manifest.getForScope(target);
                    const stringifiedIdents = [...descriptors.values()].map(descriptor => {
                        return core_3.structUtils.stringifyIdent(descriptor);
                    });
                    for (const stringifiedIdent of micromatch_1.default(stringifiedIdents, core_3.structUtils.stringifyIdent(pseudoDescriptor))) {
                        const ident = core_3.structUtils.parseIdent(stringifiedIdent);
                        const existingDescriptor = workspace.manifest[target].get(ident.identHash);
                        if (typeof existingDescriptor === `undefined`)
                            throw new Error(`Assertion failed: Expected the descriptor to be registered`);
                        const request = core_3.structUtils.makeDescriptor(ident, pseudoDescriptor.range);
                        allSuggestionsPromises.push(Promise.resolve().then(async () => {
                            return [
                                workspace,
                                target,
                                existingDescriptor,
                                await suggestUtils.getSuggestedDescriptors(request, { project, workspace, cache, target, modifier, strategies }),
                            ];
                        }));
                        isReferenced = true;
                    }
                }
            }
            if (!isReferenced) {
                unreferencedPatterns.push(pattern);
            }
        }
        if (unreferencedPatterns.length > 1)
            throw new clipanion_1.UsageError(`Patterns ${core_1.formatUtils.prettyList(configuration, unreferencedPatterns, core_1.FormatType.CODE)} don't match any packages referenced by any workspace`);
        if (unreferencedPatterns.length > 0)
            throw new clipanion_1.UsageError(`Pattern ${core_1.formatUtils.prettyList(configuration, unreferencedPatterns, core_1.FormatType.CODE)} doesn't match any packages referenced by any workspace`);
        const allSuggestions = await Promise.all(allSuggestionsPromises);
        const checkReport = await core_1.LightReport.start({
            configuration,
            stdout: this.context.stdout,
            suggestInstall: false,
        }, async (report) => {
            for (const [/*workspace*/ , /*target*/ , existing, { suggestions, rejections }] of allSuggestions) {
                const nonNullSuggestions = suggestions.filter(suggestion => {
                    return suggestion.descriptor !== null;
                });
                if (nonNullSuggestions.length === 0) {
                    const [firstError] = rejections;
                    if (typeof firstError === `undefined`)
                        throw new Error(`Assertion failed: Expected an error to have been set`);
                    const prettyError = this.cli.error(firstError);
                    if (!project.configuration.get(`enableNetwork`)) {
                        report.reportError(core_1.MessageName.CANT_SUGGEST_RESOLUTIONS, `${core_3.structUtils.prettyDescriptor(configuration, existing)} can't be resolved to a satisfying range (note: network resolution has been disabled)\n\n${prettyError}`);
                    }
                    else {
                        report.reportError(core_1.MessageName.CANT_SUGGEST_RESOLUTIONS, `${core_3.structUtils.prettyDescriptor(configuration, existing)} can't be resolved to a satisfying range\n\n${prettyError}`);
                    }
                }
                else if (nonNullSuggestions.length > 1 && !interactive) {
                    report.reportError(core_1.MessageName.CANT_SUGGEST_RESOLUTIONS, `${core_3.structUtils.prettyDescriptor(configuration, existing)} has multiple possible upgrade strategies; use -i to disambiguate manually`);
                }
            }
        });
        if (checkReport.hasErrors())
            return checkReport.exitCode();
        let askedQuestions = false;
        const afterWorkspaceDependencyReplacementList = [];
        for (const [workspace, target, /*existing*/ , { suggestions }] of allSuggestions) {
            let selected;
            const nonNullSuggestions = suggestions.filter(suggestion => {
                return suggestion.descriptor !== null;
            });
            const firstSuggestedDescriptor = nonNullSuggestions[0].descriptor;
            const areAllTheSame = nonNullSuggestions.every(suggestion => core_3.structUtils.areDescriptorsEqual(suggestion.descriptor, firstSuggestedDescriptor));
            if (nonNullSuggestions.length === 1 || areAllTheSame) {
                selected = firstSuggestedDescriptor;
            }
            else {
                askedQuestions = true;
                ({ answer: selected } = await enquirer_1.prompt({
                    type: `select`,
                    name: `answer`,
                    message: `Which range to you want to use in ${core_3.structUtils.prettyWorkspace(configuration, workspace)} â¯ ${target}?`,
                    choices: suggestions.map(({ descriptor, name, reason }) => descriptor ? {
                        name,
                        hint: reason,
                        descriptor,
                    } : {
                        name,
                        hint: reason,
                        disabled: true,
                    }),
                    onCancel: () => process.exit(130),
                    result(name) {
                        // @ts-expect-error: The enquirer types don't include find
                        return this.find(name, `descriptor`);
                    },
                    stdin: this.context.stdin,
                    stdout: this.context.stdout,
                }));
            }
            const current = workspace.manifest[target].get(selected.identHash);
            if (typeof current === `undefined`)
                throw new Error(`Assertion failed: This descriptor should have a matching entry`);
            if (current.descriptorHash !== selected.descriptorHash) {
                workspace.manifest[target].set(selected.identHash, selected);
                afterWorkspaceDependencyReplacementList.push([
                    workspace,
                    target,
                    current,
                    selected,
                ]);
            }
            else {
                const resolver = configuration.makeResolver();
                const resolveOptions = { project, resolver };
                const bound = resolver.bindDescriptor(current, workspace.anchoredLocator, resolveOptions);
                project.forgetResolution(bound);
            }
        }
        await configuration.triggerMultipleHooks((hooks) => hooks.afterWorkspaceDependencyReplacement, afterWorkspaceDependencyReplacementList);
        if (askedQuestions)
            this.context.stdout.write(`\n`);
        const installReport = await core_2.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            await project.install({ cache, report });
        });
        return installReport.exitCode();
    }
}
UpCommand.usage = clipanion_1.Command.Usage({
    description: `upgrade dependencies across the project`,
    details: `
      This command upgrades the packages matching the list of specified patterns to their latest available version across the whole project (regardless of whether they're part of \`dependencies\` or \`devDependencies\` - \`peerDependencies\` won't be affected). This is a project-wide command: all workspaces will be upgraded in the process.

      If \`-i,--interactive\` is set (or if the \`preferInteractive\` settings is toggled on) the command will offer various choices, depending on the detected upgrade paths. Some upgrades require this flag in order to resolve ambiguities.

      The, \`-C,--caret\`, \`-E,--exact\` and  \`-T,--tilde\` options have the same meaning as in the \`add\` command (they change the modifier used when the range is missing or a tag, and are ignored when the range is explicitly set).

      Generally you can see \`yarn up\` as a counterpart to what was \`yarn upgrade --latest\` in Yarn 1 (ie it ignores the ranges previously listed in your manifests), but unlike \`yarn upgrade\` which only upgraded dependencies in the current workspace, \`yarn up\` will upgrade all workspaces at the same time.

      This command accepts glob patterns as arguments (if valid Descriptors and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.

      **Note:** The ranges have to be static, only the package scopes and names can contain glob patterns.
    `,
    examples: [[
            `Upgrade all instances of lodash to the latest release`,
            `$0 up lodash`,
        ], [
            `Upgrade all instances of lodash to the latest release, but ask confirmation for each`,
            `$0 up lodash -i`,
        ], [
            `Upgrade all instances of lodash to 1.2.3`,
            `$0 up lodash@1.2.3`,
        ], [
            `Upgrade all instances of packages with the \`@babel\` scope to the latest release`,
            `$0 up '@babel/*'`,
        ], [
            `Upgrade all instances of packages containing the word \`jest\` to the latest release`,
            `$0 up '*jest*'`,
        ], [
            `Upgrade all instances of packages with the \`@babel\` scope to 7.0.0`,
            `$0 up '@babel/*@7.0.0'`,
        ]],
});
tslib_1.__decorate([
    clipanion_1.Command.Rest()
], UpCommand.prototype, "patterns", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-i,--interactive`, { description: `Offer various choices, depending on the detected upgrade paths` })
], UpCommand.prototype, "interactive", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-E,--exact`, { description: `Don't use any semver modifier on the resolved range` })
], UpCommand.prototype, "exact", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-T,--tilde`, { description: `Use the \`~\` semver modifier on the resolved range` })
], UpCommand.prototype, "tilde", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Boolean(`-C,--caret`, { description: `Use the \`^\` semver modifier on the resolved range` })
], UpCommand.prototype, "caret", void 0);
tslib_1.__decorate([
    clipanion_1.Command.Path(`up`)
], UpCommand.prototype, "execute", null);
exports.default = UpCommand;
